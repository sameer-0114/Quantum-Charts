<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Simple Chart with Heatmap Overlay</title>
    <style>
      :root[data-theme='dark'] {
        --bg: #0e1116;
        --bg-2: #111827;
        --border: #1f2937;
        --text: #cfd8e3;
        --muted: #94a3b8;
        --panel: rgba(17,24,39,0.9);
        --panel-border: #334155;
        --legend-bg: rgba(0,0,0,0.45);
        --grid: #111827;
      }
      :root[data-theme='light'] {
        --bg: #ffffff;
        --bg-2: #f3f4f6;
        --border: #e5e7eb;
        --text: #111827;
        --muted: #374151;
        --panel: rgba(255,255,255,0.95);
        --panel-border: #d1d5db;
        --legend-bg: rgba(255,255,255,0.85);
        --grid: #e5e7eb;
      }
      html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
      #app { height: 100%; display: flex; flex-direction: column; }
      header { padding: 8px 12px; background: var(--bg-2); border-bottom: 1px solid var(--border); display:flex; gap:12px; align-items:center; }
      .spacer { flex:1; }
      #chart { flex: 1; position: relative; }
      .legend { position: absolute; top: 8px; left: 8px; background: var(--legend-bg); padding: 6px 8px; border-radius: 6px; font-size: 12px; z-index: 10; }
      /* DOM Overlay styles */
      .dom-overlay { position: absolute; top: 0; bottom: 0; right: 0; width: 100%; pointer-events: none; z-index: 3; }
      canvas.dom-canvas { width: 100% !important; height: 100% !important; display: block; }
      select, button { background: var(--bg); color: var(--text); border: 1px solid var(--panel-border); border-radius: 6px; padding: 6px 8px; }
      /* Startup source selection modal */
      #sourceModal { position:fixed; inset:0; background:rgba(0,0,0,0.55); display:flex; align-items:center; justify-content:center; z-index:1000; }
      #sourceModal.hidden { display:none; }
      #sourceModal .panel { background: var(--panel); border:1px solid var(--panel-border); padding:24px 28px; border-radius:12px; width:320px; box-shadow:0 4px 24px -4px rgba(0,0,0,0.6); display:flex; flex-direction:column; gap:16px; }
      #sourceModal h2 { margin:0 0 4px; font-size:18px; }
      #sourceModal p { margin:0; font-size:13px; line-height:1.4; color: var(--muted); }
      #sourceModal button.choice { width:100%; padding:10px 12px; font-weight:600; cursor:pointer; }
      #csvStatusOverlay { position:absolute; top:48px; left:12px; background:var(--panel); border:1px solid var(--panel-border); padding:6px 10px; border-radius:8px; font-size:12px; z-index:50; display:none; }
    </style>
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.development.js"></script>
  </head>
  <body>
    <div id="app">
      <header>
        <div><strong>Chart: Monero/Tether</strong></div>
        <label>Timeframe:
          <select id="tf">
            <option value="1m" selected>1m</option>
            <option value="3m">3m</option>
            <option value="5m">5m</option>
            <option value="15m">15m</option>
            <option value="30m">30m</option>
            <option value="1h">1h</option>
            <option value="4h">4h</option>
          </select>
        </label>
        <label style="margin-left:10px;">Style:
          <select id="styleSel">
            <option value="candles" selected>Candles</option>
            <option value="hollow">Hollow</option>
            <option value="bars">H/L Bars</option>
            <option value="line">Line</option>
          </select>
        </label>
        <div class="spacer"></div>
        <button id="resetView">Reset View</button>
        <button id="themeToggle" title="Toggle theme">Dark</button>
        <label style="margin-left:8px; display:flex; align-items:center; gap:6px;">
          <span id="domStatus" style="font-size:12px; color: var(--muted);">DOM: connecting…</span>
          <button id="domToggle" title="Toggle DOM overlay">On</button>
          <select id="domTick">
            <option value="0.01">0.01</option>
            <option value="0.05">0.05</option>
            <option value="0.10" selected>0.10</option>
            <option value="0.20">0.20</option>
            <option value="0.25">0.25</option>
            <option value="0.50">0.50</option>
            <option value="1.00">1.00</option>
          </select>
          <label style="display:inline-flex; align-items:center; gap:4px; font-size:12px; color: var(--muted);">
            <input type="checkbox" id="domVisibleOnly" checked /> Visible only
          </label>
          <button id="heatmapToggle" title="Toggle historical heatmap" style="margin-left:8px;">HM Off</button>
          <label style="display:inline-flex; align-items:center; gap:6px; font-size:12px; margin-left:6px;">
            Source:
            <select id="hmSourceSel">
              <option value="db">DB</option>
              <option value="csv">CSV</option>
            </select>
          </label>
        </label>
      </header>
      <div id="chart">
        <div class="legend" id="legend"></div>
        <!-- Chart info overlay (top-left) -->
        <div id="chartInfo" style="position:absolute; top:8px; left:8px; z-index:6; display:flex; flex-direction:column; gap:6px; background: transparent; padding:6px 8px; border-radius:6px;">
          <div style="display:flex; align-items:center; gap:8px;">
            <span id="symLabel" style="font-weight:600;">XMRUSDT Chart:</span>
            <span id="ohlcvLabel" style="font-variant-numeric: tabular-nums;">O — H — L — C — V</span>
          </div>
          <div style="display:flex; align-items:center; gap:6px;">
            <button id="bestBidBtn" style="min-width:68px; padding:2px 8px; border-radius:6px; border:1px solid var(--panel-border); background: transparent; color:#ef4444; font-variant-numeric: tabular-nums;">—</button>
            <span id="spreadLabel" style="font-size:12px; color:var(--muted); min-width:60px; text-align:center; font-variant-numeric: tabular-nums;">—</span>
            <button id="bestAskBtn" style="min-width:68px; padding:2px 8px; border-radius:6px; border:1px solid var(--panel-border); background: transparent; color:#10b981; font-variant-numeric: tabular-nums;">—</button>
          </div>
        </div>
        <div class="dom-overlay"><canvas id="domCanvas" class="dom-canvas"></canvas></div>
        <div id="csvStatusOverlay">CSV loading…</div>
      </div>
    </div>
    <!-- Startup Data Source Modal -->
    <div id="sourceModal" class="hidden">
      <div class="panel">
        <h2>Data Source</h2>
        <p>Select how historical heatmap snapshots are sourced. CSV mode loads a large local file into memory and then tails new rows; DB mode queries Postgres directly.</p>
        <button id="chooseDb" class="choice">Database (Postgres)</button>
        <button id="chooseCsv" class="choice">CSV File (Low Latency)</button>
        <label style="display:flex; align-items:center; gap:6px; font-size:11px; margin-top:4px;">
          <input type="checkbox" id="rememberSource" checked /> Remember my choice
        </label>
      </div>
    </div>
    <script>
      const $ = (q) => document.querySelector(q);
      const legend = $('#legend');
      const tfSel = $('#tf');
      const chartInfo = document.getElementById('chartInfo');
      const themeToggle = $('#themeToggle');
      const domCanvas = $('#domCanvas');
      const domCtx = domCanvas.getContext('2d');

      // Info bar state
      const symLabel = document.getElementById('symLabel');
      const ohlcvLabel = document.getElementById('ohlcvLabel');
      const bestBidBtn = document.getElementById('bestBidBtn');
      const bestAskBtn = document.getElementById('bestAskBtn');
      const spreadLabel = document.getElementById('spreadLabel');

      // DOM state variables
      let domState = { mid: null, bids: [], asks: [] };
      let domEnabled = true;
      let domTickSize = 0.10;
      let domDebug = false; // set true to show bucket labels
      let domVisibleOnly = true;

  // ===== Historical heatmap (no fixed rolling window; cadence depends on TF: 4 bins per candle) =====
  function hmSnapMs() {
    try {
      const tf = tfSel.value || '1m';
      const sec = (TF_SECONDS[tf] || 60) / 4; // 4 bins per candle
      return Math.max(1, Math.round(sec * 1000));
    } catch { return 15000; }
  }
      // Snapshot structure: { t: seconds, rows: Array<[priceBucketLo:number, totalQty:number]> }
      let hmSnapshots = [];
      let hmLastSnapMs = 0;
      let hmWindowMaxQty = 1e-9; // rolling max for normalization
      // Mark dirty to force redraw (optional optimization, we currently redraw every frame anyway)
      let hmDirty = true;
      let heatmapEnabled = false; // OFF by default; still capture snapshots in background
      // Source selection: 'db' or 'csv'
      let heatmapSource = 'db';
      const SOURCE_KEY = 'heatmapSourceMode';
      const sourceModal = document.getElementById('sourceModal');
      const chooseDbBtn = document.getElementById('chooseDb');
      const chooseCsvBtn = document.getElementById('chooseCsv');
      const rememberSourceChk = document.getElementById('rememberSource');
      const csvStatusOverlay = document.getElementById('csvStatusOverlay');
  const hmSourceSel = document.getElementById('hmSourceSel');

      function applySourceChoice(src) {
        heatmapSource = src === 'csv' ? 'csv' : 'db';
        if (rememberSourceChk?.checked) {
          try { localStorage.setItem(SOURCE_KEY, heatmapSource); } catch {}
        }
        // Reset current heatmap state for new source
        clearHeatmapBuffer();
        // If switching to CSV, show loading overlay immediately
        if (heatmapSource === 'csv') {
          csvStatusOverlay.style.display = 'block';
          csvStatusOverlay.textContent = 'CSV loading…';
        } else {
          csvStatusOverlay.style.display = 'none';
        }
        if (heatmapEnabled) {
          bfAborted = false;
          startBackfillFillVisible();
          reconnectHeatmapWS();
        }
        sourceModal?.classList.add('hidden');
      }

      function ensureSourceModal(force=false) {
        if (force) {
          sourceModal?.classList.remove('hidden');
          return;
        }
        let saved = null;
        try { saved = localStorage.getItem(SOURCE_KEY); } catch {}
        if (saved === 'db' || saved === 'csv') {
          heatmapSource = saved;
          return; // no modal needed
        }
        sourceModal?.classList.remove('hidden');
      }

      chooseDbBtn?.addEventListener('click', () => applySourceChoice('db'));
      chooseCsvBtn?.addEventListener('click', async () => {
        applySourceChoice('csv');
        // Kick off CSV init if not yet started (best-effort)
        try { await fetch('/api/heatmap-csv/init', { method: 'POST' }); } catch {}
      });

      // Expose a manual re-chooser via Ctrl+Shift+S (forces modal)
      window.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.shiftKey && (e.key === 'S' || e.key === 's')) {
          // Do not clear existing selection; just force show
            ensureSourceModal(true);
        }
      });

      ensureSourceModal();
      // If CSV was previously selected, proactively start init
      if (heatmapSource === 'csv') {
        try { fetch('/api/heatmap-csv/init', { method: 'POST' }); } catch {}
      }

      // Initialize source selector and handle changes
      if (hmSourceSel) {
        hmSourceSel.value = heatmapSource;
        hmSourceSel.addEventListener('change', async () => {
          const v = hmSourceSel.value === 'csv' ? 'csv' : 'db';
          // Persist choice regardless of remember checkbox for explicit user action
          try { localStorage.setItem(SOURCE_KEY, v); } catch {}
          // Apply selection and reconnect
          applySourceChoice(v);
          // Start CSV in background if chosen
          if (v === 'csv') {
            try { fetch('/api/heatmap-csv/init', { method: 'POST' }); } catch {}
          }
        });
      }

      function updateCsvStatus(status) {
        if (heatmapSource !== 'csv') { csvStatusOverlay.style.display = 'none'; return; }
        if (!status || !status.ready) {
          csvStatusOverlay.style.display = 'block';
          if (status) {
            const pct = status.total_bytes > 0 ? (100 * status.loaded_bytes / status.total_bytes) : 0;
            csvStatusOverlay.textContent = `CSV loading… ${pct.toFixed(1)}% (${status.parsed_rows} rows)`;
          } else {
            csvStatusOverlay.textContent = 'CSV loading…';
          }
        } else {
          csvStatusOverlay.style.display = 'none';
        }
      }

      function clearHeatmapBuffer() {
        hmSnapshots = [];
        hmLastSnapMs = 0;
        hmWindowMaxQty = 1e-9;
        hmDirty = true;
      }

      function nowSec() { return Math.floor(Date.now() / 1000); }

      // Build a combined rows array (sum bids+asks per tick bucket)
      function buildHeatmapRowsFromDOM(tick) {
        if (!domState || !Array.isArray(domState.bids) || !Array.isArray(domState.asks)) return [];
        const agg = aggregateDOM(domState.bids, domState.asks, tick);
        const m = new Map();
        for (const [price, qty] of agg.bids) {
          if (!Number.isFinite(price) || !Number.isFinite(qty)) continue;
          const key = +price; // bucket low for bids (price)
          m.set(key, (m.get(key) || 0) + qty);
        }
        for (const [price, qty] of agg.asks) {
          if (!Number.isFinite(price) || !Number.isFinite(qty)) continue;
          const key = +(price - tick); // bucket low for asks (price - tick)
          m.set(key, (m.get(key) || 0) + qty);
        }
        // Convert to sorted rows by price low ascending
        const rows = Array.from(m.entries()).map(([p, q]) => [p, q]);
        rows.sort((a,b)=>a[0]-b[0]);
        return rows;
      }

      function captureHeatmapSnapshotIfDue() {
        const ms = Date.now();
        const step = hmSnapMs();
        if (hmLastSnapMs === 0) hmLastSnapMs = Math.floor(ms / step) * step;
        if (ms - hmLastSnapMs < step) return;
        hmLastSnapMs += step; // align to cadence
        // Build snapshot
        const rows = buildHeatmapRowsFromDOM(domTickSize);
        const t = nowSec();
        let localMax = 0;
        for (const r of rows) { if (r && Number.isFinite(r[1])) localMax = Math.max(localMax, r[1]); }
        hmSnapshots.push({ t, rows });
        // No rolling window trimming; keep history to cover visible range
        // Update window max (recompute if needed)
        if (localMax >= hmWindowMaxQty) {
          hmWindowMaxQty = localMax;
        } else {
          // If we popped the previous max, recompute
          let maxNow = 1e-9;
          for (const s of hmSnapshots) {
            for (const r of s.rows) { if (r && Number.isFinite(r[1])) maxNow = Math.max(maxNow, r[1]); }
          }
          hmWindowMaxQty = maxNow;
        }
        hmDirty = true;
      }

      function captureHeatmapSnapshotNow() {
        // Immediate snapshot (used on first DOM message)
        const rows = buildHeatmapRowsFromDOM(domTickSize);
        const t = nowSec();
        let localMax = 0;
        for (const r of rows) { if (r && Number.isFinite(r[1])) localMax = Math.max(localMax, r[1]); }
        hmSnapshots.push({ t, rows });
        // No rolling window trimming; keep history to cover visible range
        let maxNow = Math.max(hmWindowMaxQty, localMax);
        for (const s of hmSnapshots) {
          for (const r of s.rows) { if (r && Number.isFinite(r[1])) maxNow = Math.max(maxNow, r[1]); }
        }
        hmWindowMaxQty = Math.max(1e-9, maxNow);
        const step = hmSnapMs();
        const now = Date.now();
        hmLastSnapMs = Math.floor(now / step) * step;
        hmDirty = true;
      }

  // ===== Batch fill support (triggered when heatmap is ON) =====
      let backfillInFlight = false;
      let lastBackfillTs = 0;
      const BF_BATCH = 100; // snapshots per request
      let bfTargetFromSec = null; // inclusive lower bound to reach
      let bfCursorEndSec = null;  // exclusive upper bound to paginate downward
      let bfAborted = false;      // cancel in-progress series when toggled off
      let bfRangeDebounce = null; // timer for viewport-driven fetches
  let hmSocket = null;        // websocket for realtime heatmap updates

      function getVisibleUnixRangeSec() {
        try {
          const r = chart.timeScale().getVisibleRange();
          if (!r || typeof r.from !== 'number' || typeof r.to !== 'number') return null;
          return { from: Math.floor(r.from), to: Math.ceil(r.to) };
        } catch { return null; }
      }

      function isVisibleCovered() {
        const r = getVisibleUnixRangeSec();
        if (!r) return true;
        if (!hmSnapshots.length) return false;
        const earliestSnap = hmSnapshots[0].t;
        // With true time bins, consider coverage satisfied if the earliest snapshot time
        // reaches or precedes the visible range start
        return earliestSnap <= r.from;
      }

      async function fetchBackfillBatch() {
        if (!heatmapEnabled || bfAborted) return;
        if (backfillInFlight) return;
        if (bfCursorEndSec == null) return;
        // Stop if already covered
        if (isVisibleCovered()) return;
        backfillInFlight = true;
        try {
          const tf = tfSel.value || '1m';
          const tfSec = TF_SECONDS[tf] || 60;
          const snapSec = Math.max(1, Math.floor(hmSnapMs()/1000));
          const useTargets = tfSec >= 300; // 5m and above: request exact anchors in range
          let json = null;
          if (useTargets) {
            // Compute target anchors across current visible range at bin cadence
            const r = getVisibleUnixRangeSec();
            if (!r) return; // nothing to do
            let a = Math.floor(r.from / snapSec) * snapSec;
            const to = Math.ceil(r.to / snapSec) * snapSec;
            const existing = new Set(hmSnapshots.map(s => Math.floor(s.t)));
            const targets = [];
            while (a <= to && targets.length < 1200) { // cap to keep URL manageable
              if (!existing.has(a)) targets.push(a);
              a += snapSec;
            }
            if (targets.length === 0) {
              return; // already covered
            }
            const params = new URLSearchParams();
            params.set('format','rows');
            params.set('tick', String(domTickSize));
            params.set('source', heatmapSource);
            params.set('tf', tf);
            params.set('mode','targets');
            params.set('tol','5'); // seconds tolerance
            params.set('targets', targets.join(','));
            const url = `/api/heatmap-data?${params.toString()}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`Backfill(targets) HTTP ${res.status}`);
            json = await res.json();
          } else {
            // Use end-only pagination: fetch newest up to bfCursorEndSec in descending order
            const params = new URLSearchParams();
            params.set('format','rows');
            params.set('tick', String(domTickSize));
            params.set('end', String(bfCursorEndSec));
            params.set('limit', String(BF_BATCH));
            params.set('source', heatmapSource);
            params.set('tf', tf);
            const url = `/api/heatmap-data?${params.toString()}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`Backfill HTTP ${res.status}`);
            json = await res.json();
          }
          if (heatmapSource === 'csv' && json) updateCsvStatus(json.status);
          const batch = (json && Array.isArray(json.data)) ? json.data : [];
          if (batch.length) {
            integrateBackfillRowsSnapshots(batch);
            if (!useTargets) {
              // For pagination mode, page older by moving cursor end
              let minT = Infinity;
              for (const s of batch) if (s && typeof s.t === 'number') minT = Math.min(minT, Math.floor(s.t));
              if (Number.isFinite(minT)) {
                bfCursorEndSec = minT - 1;
              }
            }
          }
          // Continue logic:
          // - If CSV not ready yet: keep polling until ready
          if (heatmapSource === 'csv' && json && json.status && json.status.ready === false && !bfAborted) {
            setTimeout(fetchBackfillBatch, 500);
          } else if (!isVisibleCovered() && !bfAborted) {
            // - If not covered: continue even if batch is empty (CSV may have just become ready)
            setTimeout(fetchBackfillBatch, batch.length > 0 ? 0 : 150);
          }
        } catch (e) {
          console.warn('Backfill batch error', e);
        } finally {
          backfillInFlight = false;
          lastBackfillTs = Date.now();
        }
      }

      function startBackfillFillVisible() {
        if (!heatmapEnabled) return;
        const r = getVisibleUnixRangeSec();
        if (!r) return;
        bfAborted = false;
        // We only need the lower bound to know when coverage is complete; cursor starts at visible high
        bfTargetFromSec = r.from;
        bfCursorEndSec = r.to;
        fetchBackfillBatch();
      }

      function integrateBackfillSnapshots(data) {
        if (!Array.isArray(data)) return;
        // Merge oldest->newest so earlier snapshots don't overwrite newer normalization window logic
        const existingT = new Set(hmSnapshots.map(s => s.t));
        let pushed = 0;
        for (let i = data.length - 1; i >= 0; i--) { // reverse to get chronological order when unshifting later if needed
          const snap = data[i];
          if (!snap || typeof snap.timestamp !== 'number') continue;
          const t = Math.floor(snap.timestamp); // seconds
          if (existingT.has(t)) continue; // skip duplicates
          // Build combined rows using server snapshot bids/asks maps
          const bidsObj = snap.bids || {};
          const asksObj = snap.asks || {};
          const bidsArr = Object.entries(bidsObj).map(([p,q]) => [String(p), String(q)]);
          const asksArr = Object.entries(asksObj).map(([p,q]) => [String(p), String(q)]);
          const agg = aggregateDOM(bidsArr, asksArr, domTickSize);
          const m = new Map();
          for (const [price, qty] of agg.bids) {
            if (!Number.isFinite(price) || !Number.isFinite(qty)) continue;
            const key = +price; // low bucket for bids
            m.set(key, (m.get(key) || 0) + qty);
          }
          for (const [price, qty] of agg.asks) {
            if (!Number.isFinite(price) || !Number.isFinite(qty)) continue;
            const key = +(price - domTickSize); // low bucket for asks
            m.set(key, (m.get(key) || 0) + qty);
          }
          const rows = Array.from(m.entries()).map(([p,q]) => [p,q]).sort((a,b)=>a[0]-b[0]);
          hmSnapshots.push({ t, rows });
          existingT.add(t);
          pushed++;
        }
        if (!pushed) return;
        // Sort time ascending; retain full history (capped elsewhere if needed)
        hmSnapshots.sort((a,b)=>a.t-b.t);
        // Recompute rolling max
        let maxNow = 1e-9;
        for (const s of hmSnapshots) {
          for (const r of s.rows) { if (r && Number.isFinite(r[1])) maxNow = Math.max(maxNow, r[1]); }
        }
        hmWindowMaxQty = Math.max(1e-9, maxNow);
        hmDirty = true;
        lastBackfillTs = Date.now();
      }

      // Fast-path integration when server returns frontend-ready format {t, rows}
      function integrateBackfillRowsSnapshots(data) {
        if (!Array.isArray(data)) return;
        const existingT = new Set(hmSnapshots.map(s => s.t));
        let pushed = 0;
        for (let i = data.length - 1; i >= 0; i--) {
          const snap = data[i];
          if (!snap || typeof snap.t !== 'number' || !Array.isArray(snap.rows)) continue;
          const t = Math.floor(snap.t);
          if (existingT.has(t)) continue;
          const rows = snap.rows
            .map(r => [Number(r[0]), Number(r[1])])
            .filter(r => Number.isFinite(r[0]) && Number.isFinite(r[1]))
            .sort((a,b)=>a[0]-b[0]);
          hmSnapshots.push({ t, rows });
          existingT.add(t);
          pushed++;
        }
        if (!pushed) return;
        hmSnapshots.sort((a,b)=>a.t-b.t);
        let maxNow = 1e-9;
        for (const s of hmSnapshots) {
          for (const r of s.rows) { if (r && Number.isFinite(r[1])) maxNow = Math.max(maxNow, r[1]); }
        }
        hmWindowMaxQty = Math.max(1e-9, maxNow);
        hmDirty = true;
        lastBackfillTs = Date.now();
      }

      // Map normalized intensity [0,1] to perceptual blue→yellow→orange with gamma + alpha shaping
      // Goal: make low volume (blue) much less visually dominant, esp. on dark theme.
      function heatColorFor(v, isDark) {
        const clamp = (x,min,max)=>Math.max(min,Math.min(max,x));
        // Softer gamma so blues/yellows reappear (previous 1.8 was too strong)
        const gamma = 1.25; // easing
        const t = Math.pow(clamp(v, 0, 1), gamma);
        // Standard liquidity heatmap ramp (cold→hot): blue→green→yellow→orange→red (220° → 0°)
        const hueMidBias = 0.12; // linger a bit near yellow
        const hue = 220 + (0 - 220) * (t * (1 - hueMidBias) + hueMidBias * Math.sqrt(t));
        // Increase base saturation so low blues are visible again
        const sat = 0.45 + 0.50 * t; // 45%..95%
        // Rebalance lightness: raise lows a touch, keep highs similar
        const lightLow = isDark ? 0.22 : 0.60;
        const lightHigh = isDark ? 0.58 : 0.46;
        const light = lightLow + (lightHigh - lightLow) * t;

        // Convert HSL to RGB
        function hslToRgb(h, s, l){
          h = ((h%360)+360)%360; s = clamp(s,0,1); l = clamp(l,0,1);
          const c = (1 - Math.abs(2*l - 1)) * s;
          const x = c * (1 - Math.abs(((h/60) % 2) - 1));
          const m = l - c/2; let r1=0,g1=0,b1=0;
          if (h < 60) [r1,g1,b1] = [c,x,0];
          else if (h < 120) [r1,g1,b1] = [x,c,0];
          else if (h < 180) [r1,g1,b1] = [0,c,x];
          else if (h < 240) [r1,g1,b1] = [0,x,c];
          else if (h < 300) [r1,g1,b1] = [x,0,c];
          else [r1,g1,b1] = [c,0,x];
          const r = Math.round((r1 + m) * 255);
          const g = Math.round((g1 + m) * 255);
          const b = Math.round((b1 + m) * 255);
          return [r,g,b];
        }

        const [r,g,b] = hslToRgb(hue, sat, light);
        // Alpha shaped separately so low intensities barely show
        const alphaMin = isDark ? 0.10 : 0.12; // raise baseline visibility slightly
        const alpha = alphaMin + (0.80 - alphaMin) * t; // cap a bit lower to avoid overpowering
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      // ===== Helpers for time-aligned snapshot placement within bar =====
      function estimatePxPerBar() {
        try {
          const ts = chart.timeScale();
          const n = currentBars.length;
          if (n >= 2) {
            const xLast = ts.timeToCoordinate(currentBars[n-1].time);
            const xPrev = ts.timeToCoordinate(currentBars[n-2].time);
            if (xLast != null && xPrev != null) return Math.max(2, Math.abs(xLast - xPrev));
          }
        } catch {}
        return 8;
      }

      function nearestBarCenterX(bucketTime) {
        const ts = chart.timeScale();
        let x = ts.timeToCoordinate(bucketTime);
        if (x != null) return x;
        // fallback: nearest bar by time
        let best = null, bestDt = 1e12;
        for (const b of currentBars) {
          if (!b || typeof b.time !== 'number') continue;
          const dt = Math.abs(b.time - bucketTime);
          if (dt < bestDt) { bestDt = dt; best = b.time; }
        }
        if (best != null) return ts.timeToCoordinate(best);
        return null;
      }

      // Map arbitrary time (seconds) to pixel using interpolation between bar centers; fallback to per-bar width near tail
      function coordAtTimeApprox(tSec) {
        try {
          const n = currentBars.length;
          if (!n) return null;
          const ts = chart.timeScale();
          const tfSec = TF_SECONDS[tfSel.value] || 60;
          const firstT = currentBars[0].time;
          const lastT = currentBars[n-1].time;
          // Exact match fast path
          if (tSec === firstT) return ts.timeToCoordinate(firstT);
          if (tSec === lastT) return ts.timeToCoordinate(lastT);
          // Within known bar span: interpolate between neighbors
          for (let i = 0; i < n - 1; i++) {
            const ta = currentBars[i].time;
            const tb = currentBars[i+1].time;
            if (ta <= tSec && tSec <= tb) {
              const xa = ts.timeToCoordinate(ta);
              const xb = ts.timeToCoordinate(tb);
              if (xa == null || xb == null) return null;
              const r = (tSec - ta) / Math.max(1, (tb - ta));
              return xa + r * (xb - xa);
            }
          }
          // After the last known bar but still within the current bar interval: approximate using pxPerBar
          if (tSec > lastT && tSec <= lastT + tfSec) {
            const pxPerBar = Math.max(2, estimatePxPerBar());
            const xb = ts.timeToCoordinate(lastT);
            if (xb == null) return null;
            const r = (tSec - lastT) / tfSec;
            return xb + r * pxPerBar;
          }
          // Before the first or too far after the last: don't draw
          return null;
        } catch { return null; }
      }

      function xSpanForSnapshot(tSec) {
        // TRUE time bins: map snapshot interval [tSec, tSec + snapSec) via interpolated coordinates
        const snapSec = Math.max(1, Math.floor(hmSnapMs()/1000));
        const x0 = coordAtTimeApprox(tSec);
        const x1 = coordAtTimeApprox(tSec + snapSec);
        if (x0 == null || x1 == null) return { x: null, w: null };
        let x = Math.min(x0, x1);
        let w = Math.abs(x1 - x0);
        if (w < 1) w = 1;
        return { x: Math.round(x), w: Math.round(w) };
      }

      // Chart setup + theme
      const chartEl = $('#chart');
      const rootEl = document.documentElement;
      function currentTheme(){ return rootEl.getAttribute('data-theme')||'dark'; }
      function themeColors(theme){ if(theme==='light') return { bg:'#ffffff', text:'#111827', grid:'#e5e7eb', wick:'#6b7280' }; return { bg:'#0e1116', text:'#94a3b8', grid:'#111827', wick:'#64748b' }; }
      rootEl.setAttribute('data-theme','dark');
      let theme = currentTheme();
      let themeCfg = themeColors(theme);

      const chart = LightweightCharts.createChart(chartEl, {
        layout: { background: { type: 'Solid', color: themeCfg.bg }, textColor: themeCfg.text },
        grid: { vertLines: { color: themeCfg.grid }, horzLines: { color: themeCfg.grid } },
        rightPriceScale: { borderVisible: false },
        timeScale: {
          borderVisible: false,
          rightOffset: 10,
          barSpacing: 8,
          timeVisible: true,
          secondsVisible: false,
        },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        localization: { locale: navigator.language || 'en-US' },
      });

  let candleSeries = null; // active main price series
  let currentBars = []; // holds latest OHLC bars
  const TF_SECONDS = { '1m':60, '3m':180, '5m':300, '15m':900, '30m':1800, '1h':3600, '4h':14400 };

      // Style selector and series management
      let chartStyle = (localStorage.getItem('chartStyle') || 'candles');
      const styleSel = document.getElementById('styleSel');
      if (styleSel) styleSel.value = chartStyle;

      function applyFullData(bars){
        if (!candleSeries || !Array.isArray(bars)) return;
        if (chartStyle === 'line') {
          const line = bars.map(b => ({ time: b.time, value: b.close }));
          candleSeries.setData(line);
        } else {
          candleSeries.setData(bars);
        }
      }

      function updateSeriesWithBar(bar){
        if (!candleSeries || !bar) return;
        if (chartStyle === 'line') {
          candleSeries.update({ time: bar.time, value: bar.close });
        } else {
          candleSeries.update(bar);
        }
      }

      function rebuildSeries(style){
        if (candleSeries) { try { chart.removeSeries(candleSeries); } catch(e){} candleSeries = null; }
        if (style === 'bars') {
          candleSeries = chart.addBarSeries({ upColor:'#16a34a', downColor:'#ef4444', thinBars:false });
        } else if (style === 'line') {
          const color = currentTheme()==='dark' ? '#60a5fa' : '#2563eb';
          candleSeries = chart.addLineSeries({ color, lineWidth:2 });
        } else { // candles or hollow
          candleSeries = chart.addCandlestickSeries({
            upColor:'#16a34a', downColor:'#ef4444', borderDownColor:'#ef4444', borderUpColor:'#16a34a', wickDownColor: themeCfg.wick, wickUpColor: themeCfg.wick
          });
          if (style === 'hollow') {
            candleSeries.applyOptions({
              upColor:'rgba(0,0,0,0)', downColor:'rgba(0,0,0,0)', borderUpColor:'#16a34a', borderDownColor:'#ef4444', borderVisible:true,
              wickDownColor: themeCfg.wick, wickUpColor: themeCfg.wick
            });
          }
        }
        applyFullData(currentBars || []);
      }

      // Build initial series
      rebuildSeries(chartStyle);

      // Theme toggle
      themeToggle.addEventListener('click', () => {
        const newTheme = currentTheme() === 'dark' ? 'light' : 'dark';
        rootEl.setAttribute('data-theme', newTheme);
        theme = newTheme;
        themeCfg = themeColors(theme);
        themeToggle.textContent = newTheme === 'dark' ? 'Light' : 'Dark';
        
        chart.applyOptions({
          layout: { background: { type: 'Solid', color: themeCfg.bg }, textColor: themeCfg.text },
          grid: { vertLines: { color: themeCfg.grid }, horzLines: { color: themeCfg.grid } }
        });
        
        rebuildSeries(chartStyle);
        renderDOM();
        try { localStorage.setItem('theme', newTheme); } catch(e){}
      });

      // Set legend text from bar data
      function setLegendText(bar) {
        if (!bar) return;
        const isUp = bar.close >= bar.open;
        const color = isUp ? '#10b981' : '#ef4444';
        legend.innerHTML = `<span style="color:${color}">O ${bar.open?.toFixed(2) || '—'} H ${bar.high?.toFixed(2) || '—'} L ${bar.low?.toFixed(2) || '—'} C ${bar.close?.toFixed(2) || '—'}</span>`;
      }

      // Load bars from API
      async function loadBars(tf) {
        try {
          const res = await fetch(`/api/bars?tf=${encodeURIComponent(tf)}&limit=300`);
          const bars = await res.json();
          if (Array.isArray(bars) && bars.length) {
            applyFullData(bars);
            currentBars = bars;
            setLegendText(bars[bars.length-1]);
            updateOHLCVDisplay(bars[bars.length-1]);
            // Zoom into the last 20 candles on initial load and TF change
            zoomToLastNCandles(20);
          }
        } catch (e) { 
          console.warn('bars fetch error', e); 
        }
      }

      // Helper: zoom visible range to last N candles
      function zoomToLastNCandles(n) {
        try {
          if (!Array.isArray(currentBars) || currentBars.length === 0) return;
          const count = Math.max(1, Math.min(n, currentBars.length));
          const to = currentBars[currentBars.length - 1].time;
          const from = currentBars[currentBars.length - count].time;
          chart.timeScale().setVisibleRange({ from, to });
        } catch {}
      }

      // WebSocket connection for real-time updates (timeframe-aware)
      let barsSocket = null;
      let currentTF = tfSel.value;
      function connectBars(tf) {
        currentTF = tf;
        if (barsSocket) { try { barsSocket.close(); } catch {} barsSocket = null; }
        const url = `ws://${location.host}/ws/bars?tf=${encodeURIComponent(tf)}`;
        barsSocket = new WebSocket(url);
        barsSocket.onopen = () => console.log('Bars WS connected', tf);
        barsSocket.onclose = () => console.log('Bars WS disconnected', tf);
        barsSocket.onerror = () => console.log('Bars WS error', tf);

        barsSocket.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            const expectedStride = TF_SECONDS[currentTF] || 60;
            if (msg.type === 'snapshot' && Array.isArray(msg.series)) {
              // Validate stride between last two bars to ensure snapshot timeframe matches
              let strideOk = true;
              if (msg.series.length > 2) {
                const a = msg.series[msg.series.length - 1].time;
                const b = msg.series[msg.series.length - 2].time;
                strideOk = ((a - b) === expectedStride);
              }
              if (!strideOk) {
                console.warn('Ignoring snapshot with mismatched stride');
              } else {
                applyFullData(msg.series);
                currentBars = msg.series;
                updateOHLCVDisplay(msg.series[msg.series.length - 1]);
              }
            } else if (msg.type === 'update' && msg.bar) {
              // Accept update only if it matches current TF cadence or updates the running bar
              const last = currentBars[currentBars.length - 1];
              if (last && msg.bar.time !== last.time) {
                // New bar: must advance exactly one TF interval
                if ((msg.bar.time - last.time) !== expectedStride) {
                  console.warn('Discarding update with unexpected time delta', msg.bar.time - last.time, 'expected', expectedStride);
                  return;
                }
              }
              updateSeriesWithBar(msg.bar);
              if (currentBars.length && last && last.time === msg.bar.time) {
                currentBars[currentBars.length - 1] = msg.bar; // replace running bar
              } else {
                currentBars.push(msg.bar); // append new completed bar
              }
              setLegendText(msg.bar);
              updateOHLCVDisplay(msg.bar);
            }
          } catch (e) {}
        };
      }

      // Resize canvas to container size
      function fitCanvasToParent(canvas) {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.floor(rect.width * dpr);
        canvas.height = Math.floor(rect.height * dpr);
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        return dpr;
      }

      // Aggregate DOM by tick size using floor for bids and ceil for asks
      function aggregateDOM(bids, asks, tick) {
        const bmap = new Map();
        const amap = new Map();
        const t = Number(tick);
        for (const [ps, qs] of bids) {
          const p = parseFloat(ps), q = parseFloat(qs); if (!isFinite(p) || !isFinite(q)) continue;
          const bucket = Math.floor(p / t) * t;
          bmap.set(bucket, (bmap.get(bucket) || 0) + q);
        }
        for (const [ps, qs] of asks) {
          const p = parseFloat(ps), q = parseFloat(qs); if (!isFinite(p) || !isFinite(q)) continue;
          const bucket = Math.ceil(p / t) * t;
          amap.set(bucket, (amap.get(bucket) || 0) + q);
        }
        const b = Array.from(bmap.entries()).sort((a,b)=>b[0]-a[0]); // high->low
        const a = Array.from(amap.entries()).sort((a,b)=>a[0]-b[0]); // low->high
        return { bids: b, asks: a };
      }

      // Render DOM as price-aligned bars behind candles
      function renderDOM() {
        const dpr = fitCanvasToParent(domCanvas);
        const ctx = domCtx;
        ctx.clearRect(0,0,domCanvas.width, domCanvas.height);
        // Use CSS pixels by scaling the context
        const cssW = domCanvas.width / dpr;
        const cssH = domCanvas.height / dpr;
        // Compute right price scale width if available, and position overlay immediately to its left
        let priceScaleWidth = 0;
        try {
          if (candleSeries && typeof candleSeries.priceScale === 'function') {
            const ps = candleSeries.priceScale();
            if (ps && typeof ps.width === 'function') priceScaleWidth = ps.width() || 0;
          }
        } catch {}
  const chartAreaW = Math.max(0, cssW - priceScaleWidth);
  // Heatmap now covers full plot width (remove 10% exclusion)
  const overlayPct = 0.0;
  const widthPx = 0; // DOM lane width removed for heatmap full coverage
  const xStart = Math.max(0, cssW - priceScaleWidth - widthPx);
  const heatmapW = chartAreaW;
        // No shaded background; keep overlay fully transparent except the bars/lines
        if (typeof candleSeries?.priceToCoordinate !== 'function') return;

        // -------- Historical Heatmap (left ~90%) --------
        // Price window for vertical clipping
        const topPriceHM = candleSeries.coordinateToPrice(0);
        const botPriceHM = candleSeries.coordinateToPrice(cssH);
        const loPriceHM = Math.min(topPriceHM ?? -Infinity, botPriceHM ?? Infinity);
        const hiPriceHM = Math.max(topPriceHM ?? Infinity, botPriceHM ?? -Infinity);

        if (heatmapEnabled) {
          const isDark = (document.documentElement.getAttribute('data-theme') || 'dark') === 'dark';
          ctx.save();
          ctx.scale(dpr, dpr);
          ctx.save();
          ctx.beginPath();
          ctx.rect(0, 0, heatmapW, cssH);
          ctx.clip();
          let newestT = hmSnapshots.length ? hmSnapshots[hmSnapshots.length-1].t : 0;
          // Visible-only scaling for heatmap when checkbox is on: compute max from visible rows
          let maxRefHM = hmWindowMaxQty;
          if (domVisibleOnly) {
            const tfSec = TF_SECONDS[tfSel.value] || 60;
            // Only consider snapshots whose column X falls within heatmap horizontal area
            let visMax = 1e-9;
            for (let i = 0; i < hmSnapshots.length; i++) {
              const s = hmSnapshots[i];
              const pos = xSpanForSnapshot(s.t);
              if (!pos || pos.x == null || pos.w == null) continue;
              if (pos.x >= heatmapW || (pos.x + pos.w) <= 0) continue; // outside horizontal heatmap area
              for (const [pLo, qty] of s.rows) {
                if (!Number.isFinite(pLo) || !Number.isFinite(qty)) continue;
                const pHi = pLo + domTickSize;
                if (pLo <= hiPriceHM && pHi >= loPriceHM) {
                  if (qty > visMax) visMax = qty;
                }
              }
            }
            if (visMax > 1e-9) maxRefHM = visMax;
          }
          for (let i = 0; i < hmSnapshots.length; i++) {
            const s = hmSnapshots[i];
            let { x, w } = xSpanForSnapshot(s.t);
            if (x == null || w == null) continue;
            w = Math.max(1, w);
            if (x >= heatmapW || (x + w) <= 0) continue;
            if (x + w > heatmapW) w = Math.max(0, heatmapW - x);
            if (w <= 0.5) continue;
            // Keep constant intensity without time-decay now that we can load larger ranges
            let ageMul = 1.0;
            for (const [pLo, qty] of s.rows) {
              if (!Number.isFinite(pLo) || !Number.isFinite(qty)) continue;
              const pHi = pLo + domTickSize;
              if (!(pLo <= hiPriceHM && pHi >= loPriceHM)) continue;
              const y1 = candleSeries.priceToCoordinate(pHi);
              const y2 = candleSeries.priceToCoordinate(pLo);
              if (y1 == null || y2 == null) continue;
              const top = Math.min(y1, y2), bot = Math.max(y1, y2);
              const yTop = Math.max(0, top), yBot = Math.min(cssH, bot);
              const h = yBot - yTop;
              if (h <= 0.5) continue;
              const norm = Math.min(1, (qty / Math.max(1e-9, maxRefHM)));
              const color = heatColorFor(norm * ageMul, isDark);
              ctx.fillStyle = color;
              ctx.fillRect(Math.floor(x), Math.floor(yTop), Math.ceil(w), Math.max(1, Math.floor(h)));
            }
          }
          ctx.restore();
          ctx.restore();
        }

        if (!domEnabled) return;
        if ((!domState.bids?.length) && (!domState.asks?.length)) return;

        // Aggregate
        const agg = aggregateDOM(domState.bids, domState.asks, domTickSize);

        function yOfPrice(price) { return candleSeries.priceToCoordinate(price); }
        function barColor(type, v) {
          // v in [0,1] -> intensity via alpha; higher volume => darker
          const alpha = 0.12 + 0.58*v;
          if (type==='bid') return `rgba(16, 185, 129, ${alpha})`;
          return `rgba(239, 68, 68, ${alpha})`;
        }

  // Determine visible price window (approximate via top/bottom pixel->price)
  const topPrice = candleSeries.coordinateToPrice(0);
  const botPrice = candleSeries.coordinateToPrice(cssH);
  const loPrice = Math.min(topPrice ?? -Infinity, botPrice ?? Infinity);
  const hiPrice = Math.max(topPrice ?? Infinity, botPrice ?? -Infinity);

        // Compute max quantity only for visible buckets to improve contrast
        let maxQty = 1e-9;
        let dbgCount = 0;
        for (const [price, qty] of agg.asks) {
          if (domVisibleOnly) {
            const pHi = price, pLo = price - domTickSize; if (!(pLo <= hiPrice && pHi >= loPrice)) continue;
          }
          maxQty = Math.max(maxQty, qty);
        }
        for (const [price, qty] of agg.bids) {
          if (domVisibleOnly) {
            const pHi = price + domTickSize, pLo = price; if (!(pLo <= hiPrice && pHi >= loPrice)) continue;
          }
          maxQty = Math.max(maxQty, qty);
        }

        // Helper function to get text color based on volume intensity and type
        function getVolumeTextColor(type, v) {
          // Detect current theme
          const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
          
          if (type === 'ask') {
            // Red color variations based on volume intensity and theme
            if (isDarkMode) {
              // Dark mode: Use brighter reds for better contrast on dark backgrounds
              if (v < 0.2) {
                return '#ff9999'; // Light red for very low volume
              } else if (v < 0.4) {
                return '#ff7777'; // Medium-light red
              } else if (v < 0.6) {
                return '#ff5555'; // Medium red
              } else if (v < 0.8) {
                return '#ff3333'; // Bright red
              } else {
                return '#ff1111'; // Very bright red for highest volume
              }
            } else {
              // Light mode: Use darker reds for better contrast on light backgrounds
              if (v < 0.2) {
                return '#cc4444'; // Dark red for very low volume
              } else if (v < 0.4) {
                return '#bb2222'; // Medium-dark red
              } else if (v < 0.6) {
                return '#aa0000'; // Dark red
              } else if (v < 0.8) {
                return '#880000'; // Very dark red
              } else {
                return '#660000'; // Darkest red for highest volume
              }
            }
          } else {
            // Green color variations based on volume intensity and theme
            if (isDarkMode) {
              // Dark mode: Use brighter greens for better contrast on dark backgrounds
              if (v < 0.2) {
                return '#99ff99'; // Light green for very low volume
              } else if (v < 0.4) {
                return '#77ff77'; // Medium-light green
              } else if (v < 0.6) {
                return '#55ff55'; // Medium green
              } else if (v < 0.8) {
                return '#33ff33'; // Bright green
              } else {
                return '#11ff11'; // Very bright green for highest volume
              }
            } else {
              // Light mode: Use much darker greens for better contrast on light backgrounds
              if (v < 0.2) {
                return '#228B22'; // Forest green for very low volume
              } else if (v < 0.4) {
                return '#006600'; // Dark green
              } else if (v < 0.6) {
                return '#004400'; // Darker green
              } else if (v < 0.8) {
                return '#003300'; // Very dark green
              } else {
                return '#002200'; // Darkest green for highest volume
              }
            }
          }
        }

        // Helper function to get font size based on bar height
        function getFontSize(barHeight) {
          if (barHeight < 16) return 8;
          if (barHeight < 24) return 9;
          if (barHeight < 32) return 10;
          if (barHeight < 40) return 11;
          return 12;
        }

        // Helper function to format volume display
        function formatVolume(qty) {
          if (qty >= 1000000) {
            return (qty / 1000000).toFixed(1) + 'M';
          } else if (qty >= 1000) {
            return (qty / 1000).toFixed(1) + 'K';
          } else if (qty >= 100) {
            return qty.toFixed(0);
          } else if (qty >= 10) {
            return qty.toFixed(1);
          } else {
            return qty.toFixed(2);
          }
        }

  ctx.save(); ctx.scale(dpr, dpr);
        // Draw asks (above mid), then bids (below mid). Each tick bucket spans from price to price +/- tick
        let drawn = 0;
        for (const [price, qty] of agg.asks) {
          // Bucket [price - tick, price]
          const pHi = price; const pLo = price - domTickSize;
          if (!isFinite(pHi) || !isFinite(pLo)) continue;
          if (domVisibleOnly && !(pLo <= hiPrice && pHi >= loPrice)) continue; // skip if outside visible range
          const y1 = yOfPrice(pHi); const y2 = yOfPrice(pLo);
          if (y1==null || y2==null) continue;
          const top = Math.min(y1, y2), bot = Math.max(y1, y2);
          const v = Math.min(1, qty / maxQty);
          const w = Math.max(2, widthPx); // constant width, full overlay
          const yTop = Math.max(0, top), yBot = Math.min(cssH, bot);
          const barHeight = yBot - yTop;
          if (yBot > yTop) {
            ctx.fillStyle = barColor('ask', v); 
            ctx.fillRect(xStart, yTop, w, Math.max(1, barHeight-1)); 
            drawn++;
            
            // Always show volume text (not just in debug mode)
            if (barHeight > 12) { // Only show text if bar is tall enough
              const textColor = getVolumeTextColor('ask', v);
              const fontSize = getFontSize(barHeight);
              ctx.fillStyle = textColor;
              ctx.font = `bold ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
              ctx.textAlign = 'center';
              const volumeText = formatVolume(qty);
              
              // Center the text both horizontally and vertically
              const textX = xStart + w / 2; // Center horizontally in the bar
              const textY = yTop + barHeight / 2 + fontSize / 3; // Center vertically with slight adjustment for baseline
              
              ctx.fillText(volumeText, textX, textY);
            }
            
            if (domDebug && dbgCount < 3) { 
              ctx.fillStyle = '#f87171'; 
              ctx.font='11px system-ui, -apple-system, Segoe UI, Roboto, sans-serif'; 
              ctx.fillText(`${price.toFixed ? price.toFixed(2):price} • ${qty.toFixed ? qty.toFixed(2):qty}`, xStart+4, yTop+12); 
              dbgCount++; 
            }
          }
        }
        dbgCount = 0;
        for (const [price, qty] of agg.bids) {
          // Bucket [price, price + tick]
          const pLo = price; const pHi = price + domTickSize;
          if (!isFinite(pHi) || !isFinite(pLo)) continue;
          if (domVisibleOnly && !(pLo <= hiPrice && pHi >= loPrice)) continue;
          const y1 = yOfPrice(pHi); const y2 = yOfPrice(pLo);
          if (y1==null || y2==null) continue;
          const top = Math.min(y1, y2), bot = Math.max(y1, y2);
          const v = Math.min(1, qty / maxQty);
          const w = Math.max(2, widthPx); // constant width, full overlay
          const yTop = Math.max(0, top), yBot = Math.min(cssH, bot);
          const barHeight = yBot - yTop;
          if (yBot > yTop) {
            ctx.fillStyle = barColor('bid', v); 
            ctx.fillRect(xStart, yTop, w, Math.max(1, barHeight-1)); 
            drawn++;
            
            // Always show volume text (not just in debug mode)
            if (barHeight > 12) { // Only show text if bar is tall enough
              const textColor = getVolumeTextColor('bid', v);
              const fontSize = getFontSize(barHeight);
              ctx.fillStyle = textColor;
              ctx.font = `bold ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
              ctx.textAlign = 'center';
              const volumeText = formatVolume(qty);
              
              // Center the text both horizontally and vertically
              const textX = xStart + w / 2; // Center horizontally in the bar
              const textY = yTop + barHeight / 2 + fontSize / 3; // Center vertically with slight adjustment for baseline
              
              ctx.fillText(volumeText, textX, textY);
            }
            
            if (domDebug && dbgCount < 3) { 
              ctx.fillStyle = '#34d399'; 
              ctx.font='11px system-ui, -apple-system, Segoe UI, Roboto, sans-serif'; 
              ctx.fillText(`${price.toFixed ? price.toFixed(2):price} • ${qty.toFixed ? qty.toFixed(2):qty}`, xStart+4, yTop+12); 
              dbgCount++; 
            }
          }
        }
        if (drawn === 0 && domVisibleOnly) {
          ctx.fillStyle = 'rgba(239,68,68,0.7)';
          ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.fillText('No DOM levels in view (adjust tick or zoom)', xStart + 6, 16);
        }
        // Mid-price line if available
        if (Number.isFinite(domState.mid)) {
          const my = yOfPrice(domState.mid);
          if (my != null && my >= 0 && my <= cssH) {
            ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 1; ctx.setLineDash([4,2]);
            ctx.beginPath(); ctx.moveTo(xStart, my); ctx.lineTo(xStart + widthPx, my); ctx.stroke(); ctx.setLineDash([]);
          }
        }
        ctx.restore();
      }

      // Event listeners
      tfSel.addEventListener('change', () => { 
        const tf = tfSel.value; 
        loadBars(tf); 
        connectBars(tf); 
        // Update heatmap cadence and stream to match new timeframe
        clearHeatmapBuffer();
        if (heatmapEnabled) { reconnectHeatmapWS(); startBackfillFillVisible(); }
      });
  $('#resetView').addEventListener('click', () => zoomToLastNCandles(20));
      
      // Style selector listener
      if (styleSel) {
        styleSel.addEventListener('change', () => {
          chartStyle = styleSel.value;
          try { localStorage.setItem('chartStyle', chartStyle); } catch(e){}
          rebuildSeries(chartStyle);
          renderDOM();
        });
      }

      themeToggle.textContent = 'Light';

      // Connect DOM WS and render overlay
      let domSocket = null;
      let lastDomAt = 0;
      function connectDOM() {
        if (domSocket) try { domSocket.close(); } catch {}
        domSocket = new WebSocket(`ws://${location.host}/ws/dom`);
        const statusEl = document.getElementById('domStatus');
        if (statusEl) statusEl.textContent = 'DOM: connecting…';
        domSocket.onopen = () => { if (statusEl) statusEl.textContent = 'DOM: connected'; };
        domSocket.onclose = () => { if (statusEl) statusEl.textContent = 'DOM: disconnected'; };
        domSocket.onerror = () => { if (statusEl) statusEl.textContent = 'DOM: error'; };
        domSocket.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            if (msg.type === 'dom') {
              domState = { mid: msg.mid, bids: msg.bids, asks: msg.asks };
              lastDomAt = Date.now();
              if (statusEl) statusEl.textContent = `DOM: ${msg.bids?.length||0} bids / ${msg.asks?.length||0} asks`;
              // Ensure the first historical snapshot is taken immediately on initial DOM data
              if (hmSnapshots.length === 0) {
                captureHeatmapSnapshotNow();
              }
              updateBBOAndSpread();
            }
          } catch {}
        };
      }

      // Animation loop for overlay drawing (decoupled from WS ticks)
  function loop() { requestAnimationFrame(loop); captureHeatmapSnapshotIfDue(); renderDOM(); }
      loop();

      // Resize handling
      const ro = new ResizeObserver(() => { 
        chart.applyOptions({ width: chartEl.clientWidth, height: chartEl.clientHeight }); 
        renderDOM();
      });
      ro.observe(chartEl);

      // ===== Info bar logic =====
      function fmt(n, dp=2) { return (Number.isFinite(n) ? n.toFixed(dp) : '—'); }
      function updateOHLCVDisplay(bar) {
        if (!bar) return;
        const isUp = bar.close >= bar.open;
        const color = isUp ? '#10b981' : '#ef4444';
        const parts = [
          `O ${fmt(bar.open)}`,
          `H ${fmt(bar.high)}`,
          `L ${fmt(bar.low)}`,
          `C ${fmt(bar.close)}`,
          `V ${fmt(bar.volume ?? 0, 2)}`
        ];
        ohlcvLabel.textContent = parts.join('  ');
        ohlcvLabel.style.color = color;
      }

  function updateOHLCVToLast() {
    if (currentBars && currentBars.length) updateOHLCVDisplay(currentBars[currentBars.length-1]);
  }
  function updateBBOAndSpread() {
    if (!domState || !domState.bids || !domState.asks) return;
    // best bid = highest bid price, best ask = lowest ask price
    let bestBid = null, bestAsk = null;
    if (domState.bids.length) {
      const [p, q] = domState.bids[0]; bestBid = parseFloat(p);
    }
    if (domState.asks.length) {
      const [p, q] = domState.asks[0]; bestAsk = parseFloat(p);
    }
    if (bestBid != null) {
      bestBidBtn.textContent = fmt(bestBid, 2);
    }
    if (bestAsk != null) {
      bestAskBtn.textContent = fmt(bestAsk, 2);
    }
    if (bestBid != null && bestAsk != null) {
      const spr = bestAsk - bestBid;
      spreadLabel.textContent = `Spread ${fmt(spr, 2)}`;
    } else {
      spreadLabel.textContent = '—';
    }
  }
  // Future: place orders on click
  bestBidBtn?.addEventListener('click', () => { console.log('Click best bid'); /* TODO: send order */ });
  bestAskBtn?.addEventListener('click', () => { console.log('Click best ask'); /* TODO: send order */ });
  // Restore to last bar when cursor leaves chart area
  chartEl.addEventListener('mouseleave', updateOHLCVToLast);      // Initial load
  loadBars(tfSel.value);
  connectBars(tfSel.value);
      connectDOM();

      // Keep backfilling as the user pans/zooms so the visible area is fully covered
      try {
        chart.timeScale().subscribeVisibleTimeRangeChange((range) => {
          if (!heatmapEnabled) return;
          if (!range || typeof range.from !== 'number' || typeof range.to !== 'number') return;
          const fromSec = Math.floor(range.from);
          const toSec = Math.ceil(range.to);
          if (bfTargetFromSec == null || fromSec < bfTargetFromSec) bfTargetFromSec = fromSec;
          // If user scrolled forward (later), we can advance cursor end to new high
          if (toSec > bfCursorEndSec) bfCursorEndSec = toSec;
          // Debounce to avoid over-fetching on continuous zoom/pan
          if (bfRangeDebounce) clearTimeout(bfRangeDebounce);
          bfRangeDebounce = setTimeout(() => {
            if (!isVisibleCovered()) fetchBackfillBatch();
          }, 120);
        });
      } catch {}

      // DOM controls
      const domToggle = document.getElementById('domToggle');
      const domTickSel = document.getElementById('domTick');
      const domVisibleOnlyChk = document.getElementById('domVisibleOnly');
      
      // DOM event handlers
      domToggle.addEventListener('click', () => { 
        domEnabled = !domEnabled; 
        domToggle.textContent = domEnabled ? 'On' : 'Off'; 
        try { localStorage.setItem('domEnabled', String(domEnabled)); } catch {}; 
        renderDOM(); 
      });
      domTickSel.addEventListener('change', () => { 
        domTickSize = parseFloat(domTickSel.value); 
        try { localStorage.setItem('domTickSize', String(domTickSize)); } catch {}; 
        // Tick size changed: purge heatmap buffer to keep consistency
        clearHeatmapBuffer();
        // If heatmap is enabled, refetch historical data at new tick size and reconnect WS
        if (heatmapEnabled) {
          bfAborted = false;
          startBackfillFillVisible();
          reconnectHeatmapWS();
        }
        renderDOM(); 
      });
      domVisibleOnlyChk.addEventListener('change', () => { 
        domVisibleOnly = domVisibleOnlyChk.checked; 
        try { localStorage.setItem('domVisibleOnly', String(domVisibleOnly)); } catch {}; 
        renderDOM(); 
      });

      // Heatmap toggle control (default OFF), persists in localStorage
  const heatmapToggleBtn = document.getElementById('heatmapToggle');
      if (heatmapToggleBtn) {
        heatmapToggleBtn.addEventListener('click', () => {
          heatmapEnabled = !heatmapEnabled;
          heatmapToggleBtn.textContent = heatmapEnabled ? 'HM On' : 'HM Off';
          try { localStorage.setItem('heatmapEnabled', String(heatmapEnabled)); } catch {}
          if (heatmapEnabled) {
            bfAborted = false;
            startBackfillFillVisible();
            connectHeatmapWS();
          } else {
            bfAborted = true;
            disconnectHeatmapWS();
          }
          renderDOM();
        });
        // restore previous state (default FALSE)
        try {
          const savedHM = localStorage.getItem('heatmapEnabled');
          if (savedHM != null) {
            heatmapEnabled = savedHM === 'true';
            heatmapToggleBtn.textContent = heatmapEnabled ? 'HM On' : 'HM Off';
            if (heatmapEnabled) { startBackfillFillVisible(); connectHeatmapWS(); }
          }
        } catch {}
      }

      // Backfill toggle (default OFF). When enabling: fetch and merge snapshots. When disabling: clear buffer & seed current snapshot.
      // Removed backfill toggle logic; batch fill auto-starts when heatmap is enabled.

      // Restore persisted DOM settings
      try {
        const savedDomEnabled = localStorage.getItem('domEnabled');
        const savedTick = localStorage.getItem('domTickSize');
        const savedVisOnly = localStorage.getItem('domVisibleOnly');
        if (savedDomEnabled != null) domEnabled = savedDomEnabled === 'true';
        if (savedTick != null) domTickSize = parseFloat(savedTick);
        if (savedVisOnly != null) domVisibleOnly = savedVisOnly === 'true';
      } catch {}
      
      // Initialize DOM control states
      domToggle.textContent = domEnabled ? 'On' : 'Off';
      domTickSel.value = (domTickSize || 0.10).toFixed(2);
      domVisibleOnlyChk.checked = !!domVisibleOnly;

      // Restore persisted settings
      try {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
          rootEl.setAttribute('data-theme', savedTheme);
          theme = savedTheme;
          themeCfg = themeColors(theme);
          themeToggle.textContent = savedTheme === 'dark' ? 'Light' : 'Dark';
          chart.applyOptions({
            layout: { background: { type: 'Solid', color: themeCfg.bg }, textColor: themeCfg.text },
            grid: { vertLines: { color: themeCfg.grid }, horzLines: { color: themeCfg.grid } }
          });
          rebuildSeries(chartStyle);
          renderDOM();
        }
      } catch {}

      // Heatmap realtime WebSocket helpers
      function connectHeatmapWS() {
        disconnectHeatmapWS();
        try {
          const ws = new WebSocket(`ws://${location.host}/ws/heatmap?tick=${encodeURIComponent(domTickSize)}&source=${encodeURIComponent(heatmapSource)}&tf=${encodeURIComponent(tfSel.value || '1m')}`);
          hmSocket = ws;
          ws.onmessage = (ev) => {
            try {
              const msg = JSON.parse(ev.data);
              if (msg && msg.type === 'hm' && msg.snap && typeof msg.snap.t === 'number' && Array.isArray(msg.snap.rows)) {
                integrateBackfillRowsSnapshots([msg.snap]);
              }
            } catch {}
          };
          ws.onclose = () => { /* optionally auto-reconnect when HM is enabled */ if (heatmapEnabled) setTimeout(connectHeatmapWS, 1000); };
        } catch {}
      }
      function disconnectHeatmapWS() {
        try { if (hmSocket) hmSocket.close(); } catch {}
        hmSocket = null;
      }
      function reconnectHeatmapWS() { if (heatmapEnabled) { disconnectHeatmapWS(); connectHeatmapWS(); } }
    </script>
  </body>
</html>
